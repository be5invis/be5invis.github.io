<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="I am surprised that nobody actually did a mathematical analysis of the variation model in OpenType. They are simply reusing the concepts of the old MM system, and complicating the things they need. St"><meta property="og:type" content="article"><meta property="og:title" content="Analyzing VariationÂ Models"><meta property="og:url" content="http://typeof.net/2019/analyzing-variation-model/index.html"><meta property="og:site_name" content="Typeof.net"><meta property="og:description" content="I am surprised that nobody actually did a mathematical analysis of the variation model in OpenType. They are simply reusing the concepts of the old MM system, and complicating the things they need. St"><meta property="og:locale"><meta property="article:published_time" content="2019-04-15T07:00:00.000Z"><meta property="article:modified_time" content="2019-12-25T09:41:25.259Z"><meta property="article:author" content="Belleve Invis"><meta property="article:tag" content="Typeface"><meta property="article:tag" content="Geometry"><meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/images/favicon.ico"><title>Analyzing VariationÂ Models</title><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/lib/iosevka/Iosevka.css"><link rel="stylesheet" href="/lib/iosevka-slab/IosevkaSlab.css"><link rel="stylesheet" href="/lib/source-serif-4/webfont.css"><link rel="stylesheet" href="/lib/math-symbol/symbol.css"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Typeof.net" type="application/atom+xml"></head><body><div class="content index width mx-auto px2 my4"><header id="header"><a href="/" title="home"><div id="title"><h1><span class="k">|<i>---</i></span> Typeof.net</h1></div></a></header><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="post-title" itemprop="name headline">Analyzing VariationÂ Models</h1><div class="meta"><span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Belleve Invis</span></span><div class="postdate">Â· <time datetime="2019-04-15T07:00:00.000Z" itemprop="datePublished">2019-04-15</time></div><div class="article-tag"><a class="tag-link-link" href="/tags/Geometry/" rel="tag">Geometry</a>, <a class="tag-link-link" href="/tags/Typeface/" rel="tag">Typeface</a></div></div></header><div class="content" itemprop="articleBody"><p>I am surprised that nobody actually did a mathematical analysis of the variation model in OpenType. They are simply reusing the concepts of the old MM system, and complicating the things they need.</p><h2>Standard variations</h2><p>For almost all places in a current variable font, anything that varies (coordinates, lengths, parameters, etc.) could be expressed in the following model:</p><figure class="highlight plaintext"><figcaption><span>right left</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x hat (v) &amp; = x bar + sum __ &#123;m in mfrakM_x&#125; D_x[m]W(m, v)  # 1</span><br><span class="line">W(m,v) &amp; = prod __ &#123;a in mfrakA&#125; Lambda (m[a], v[a]) # 2</span><br></pre></td></tr></table></figure><p>The notation <span class="eqn"><var>xÌ‚</var></span> denotes a variable quantity (VQ), which responds to an instance tuple <span class="eqn"><var>v</var></span>. <span class="eqn"><var>xÌ„</var></span> is the default value of <span class="eqn"><var>xÌ‚</var></span>. <span class="eqn"><xc>ğ”</xc><span class="r ss" style="height:1.2em;vertical-align:0"><span class="eb start">{</span><span class="ri" style="top:-.27142857142857135em;font-size:.7em"><span class="sp"></span></span><span class="ri" style="top:.7857142857142857em;font-size:.7em"><var>x</var></span><span class="eb end">}</span></span></span> represents the region set of <span class="eqn"><var>xÌ‚</var></span>, and <span class="eqn"><var>D</var><span class="r ss" style="height:1.2em;vertical-align:0"><span class="eb start">{</span><span class="ri" style="top:-.27142857142857135em;font-size:.7em"><span class="sp"></span></span><span class="ri" style="top:.7857142857142857em;font-size:.7em"><var>x</var></span><span class="eb end">}</span></span><span class="e bn l"><span class="BracketStart">[</span></span><var>m</var><span class="e bn r"><span class="BracketEnd">]</span></span></span> is the delta associated with this master <span class="eqn"><var>m</var></span>. Binary function <span class="eqn"><var>W</var><span class="e bn l"><span class="BracketStart">(</span></span><var>m</var><span class="kern" style="margin-left:.0625em"><span class="Punct">,</span></span><span class="kern" style="margin-left:.25em"><var>v</var></span><span class="e bn r"><span class="BracketEnd">)</span></span></span> computes the weight of master <span class="eqn"><var>m</var></span> under instance <span class="eqn"><var>v</var></span>, which is defined as a product of axis weights.</p><p>We can easily conclude that VQs form a linear space, since scalar product and sum can be defined in such manner:</p><figure class="highlight plaintext"><figcaption><span>right left</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(s cdot x hat)(v) &amp; = (s x bar) + sum __ &#123;m in mfrakM_x&#125; (s D_x[m])W(m, v)  # 3</span><br><span class="line">(x hat + y hat) (v) &amp; = (x bar + y bar) + sum __ &#123;m in mfrakM_x cup mfrakM_y&#125; (D_x[m] + D_y[m])W(m, v) # 4</span><br></pre></td></tr></table></figure><p>One thing we could not define yet is the product of two VQs, weâ€™d like to discuss them later.</p><p>Youâ€™ve noticed that the entire variation model is a <em>sum</em>, instead of <em>blending</em> values across masters. However, conversion from blending into VQ could be easily achieved by solving a linear system.</p><h2>Nested variations</h2><p>One interesting special case happens in CFF2: in theory, the <code>blend</code> operators in CFF2 could be nested, so equation <a href="#eqn-anchor-1">(1)</a> would be modified into this form:</p><figure class="highlight plaintext"><figcaption><span>right left</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x hat (v) &amp; = x bar + sum __ &#123;m in mfrakM_x&#125; &#123;D hat&#125;_x[m](v)W(m, v)  # 5</span><br></pre></td></tr></table></figure><p>The only difference is that the factor <span class="eqn"><var>DÌ‚</var><span class="r ss" style="height:1.2em;vertical-align:0"><span class="eb start">{</span><span class="ri" style="top:-.27142857142857135em;font-size:.7em"><span class="sp"></span></span><span class="ri" style="top:.7857142857142857em;font-size:.7em"><var>x</var></span><span class="eb end">}</span></span><span class="e bn l"><span class="BracketStart">[</span></span><var>m</var><span class="e bn r"><span class="BracketEnd">]</span></span><span class="e bn l"><span class="BracketStart">(</span></span><var>v</var><span class="e bn r"><span class="BracketEnd">)</span></span></span> is now a VQ instead of a number. However the property that VQs form a linear space still holds, since we can recursively scale or sum VQs in <a href="#eqn-anchor-5">(5)</a>.</p><h2>Products of variations</h2><p>One thing weâ€™d like to extend current standard is allowing products <span class="eqn"><span class="e bn l"><span class="BracketStart">(</span></span><var>xÌ‚</var><span class="kern" style="margin-left:.25em"><span class="Bin">â‹…</span></span><span class="kern" style="margin-left:.25em"><var>yÌ‚</var></span><span class="e bn r"><span class="BracketEnd">)</span></span></span> be representable in the variation system, and that is surprisingly simple by allowing axes to repeat in masters (variation regions). The product</p><figure class="highlight plaintext"><figcaption><span>right left</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(x hat cdot y hat)(v) &amp; = x bar cdot y bar # 6</span><br><span class="line"> &amp; + (x bar cdot y hat) (v) # 7</span><br><span class="line"> &amp; + (y bar cdot x hat) (v) # 8</span><br><span class="line"> &amp; + sum __ &#123;m_x in mfrakM_x&#125; ~ sum __ &#123;m_y in mfrakM_x&#125; \</span><br><span class="line">    (D_x[m_x] cdot D_y[m_y]) W(m_x, v)W(m_y, v) # 9</span><br></pre></td></tr></table></figure><p>The term <a href="#eqn-anchor-6">(6)</a>, <a href="#eqn-anchor-7">(7)</a>, <a href="#eqn-anchor-8">(8)</a> are simply scales of VQs, but term <a href="#eqn-anchor-9">(9)</a> contains product of weight functions that is not representable in the current standard. However releasing this restriction is surprisingly simple: we can allow masters to contain an axis list, which may have duplicate axes, and associate a â€œtentâ€ (start-peak-end triplet) to each axis item. In the current standard, the axis list is a fixed list shared across the entire font.</p><p>In other terms, the form of <a href="#eqn-anchor-2">(2)</a> would be modified into this form:</p><figure class="highlight plaintext"><figcaption><span>right left</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W(m,v) &amp; = prod __ &#123;(a, tau) in mfrakA[m]&#125; Lambda(tau, v[a]) # 10</span><br></pre></td></tr></table></figure><p>Notation <span class="eqn"><xc>ğ”„</xc><span class="e bn l"><span class="BracketStart">[</span></span><var>m</var><span class="e bn r"><span class="BracketEnd">]</span></span></span> denotes the â€œaxis-tentâ€ list that forms this master, and we do the same product just like the old definition. Then the product of two weighting functions could be defined as:</p><figure class="highlight plaintext"><figcaption><span>right left</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W(m_x, v)W(m_y, v) &amp; = prod __ &#123;(a, tau) in mfrakA[m_x] mfrakA[m_y]&#125; Lambda(tau, v[a]) # 11</span><br></pre></td></tr></table></figure><p>where notation <span class="eqn"><xc>ğ”„</xc><span class="e bn l"><span class="BracketStart">[</span></span><var>m</var><span class="r ss" style="height:1.2em;vertical-align:0"><span class="eb start">{</span><span class="ri" style="top:-.27142857142857135em;font-size:.7em"><span class="sp"></span></span><span class="ri" style="top:.7857142857142857em;font-size:.7em"><var>x</var></span><span class="eb end">}</span></span><span class="e bn r"><span class="BracketEnd">]</span></span><xc>ğ”„</xc><span class="e bn l"><span class="BracketStart">[</span></span><var>m</var><span class="r ss" style="height:1.2em;vertical-align:0"><span class="eb start">{</span><span class="ri" style="top:-.27142857142857135em;font-size:.7em"><span class="sp"></span></span><span class="ri" style="top:.7857142857142857em;font-size:.7em"><var>y</var></span><span class="eb end">}</span></span><span class="e bn r"><span class="BracketEnd">]</span></span></span> denotes we simply concatenate the axis-tent lists together.</p><h2>Mutatormath, etc.</h2><p><a target="_blank" rel="noopener" href="https://github.com/LettError/MutatorMath">Mutatormath</a> and libraries similar to that defines how we convert a set of <em>peak tuples</em> into a master set, where each master requires each axisâ€™ record having a <em>start</em> and an <em>end</em>, as well as the <em>peak</em> already given. Once the master set is decided, the interpolation part could be easily done by solving linear systems.</p><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css"></div></article></div><footer id="footer"><div class="footer-left"><p>Copyright &copy; 2024 Belleve Invis. Powered by Hexo. Hosted by GitHub.</p></div></footer></body></html>